/**

\section def-file-naming Naming

Each definition file specifies the data structure of the corresponding node type. 
The file must have the same name as the type and be placed in the \em definitions 
directory of the classpath. 

If the type is in a namespace, the definition file must be in a subdirectory having
the same name as the namespace. For example a type \em ab_cd_SomeType will have it's
definition file in:

    {classpath}/definitions/ab/cd/SomeType.def
    
While a type in the root namespace, for example \em MyType will be located directly
on the \em definitions directory root:

    {classpath}/definitions/MyType.def

@sa \ref type-names
    
Usually you should start coding with Graphene in unfrozen mode (see \ref freeze-unfreeze)
and the definition files will be created automatically.

But of course you can do it the other way aroud, if you like it better: creating the
definition files first, and then start coding, which is a more traditional approach.

\section def-file-syntax Syntax

\subsection def-file-comments Comments

Comments are lines that start with a '#' character. Such lines will be ignored by
the interpreter and can be used for annotations. The files generated by graphene 
have a headline comment with the type name, and before each generated property
there is a comment like this:

    # AUTO-GENERATED
    
You should remove that comment when you revise the property, so you will remember
it is not the auto-generated version anymore, and place your own comments.

\subsection def-file-directives Directives

Comments by side, the first lines a def file can contain are the (optional) directives.

The general syntax for a directive is:

    \\DIRECTIVE_NAME [DIRECTIVE_PARAMS]

At the time being there are only two directives:

    \\frozen 

Which tells the whole type is frozen, i.e. Graphene will not add any
property nor modify the existing ones.

The second directive you can insert is:

    \\supertype TYPE_NAME

Which indicates that this type extends another type.
The type name will be interpreted as relative to the current type's namespace.

@sa \ref type-names

\subsection property-defs Property definitions

The syntax of a property definition is:

    PROP_DEF := (NODE_TYPE|DATA_TYPE)[CARDINALITY] NAME ["as" ALIAS] [MASK] [FLAGS] ["!"]


NODE_TYPE is the type of node that is expected as value of that property. 
For example:

    Person owner
    
Indicates that the \em owner property should have Person nodes as values.

@sa \ref type-names

For data properties (i.e. not node properties), you write the insead th DATA_TYPE, 
which is one among following:

- int
- float                                       
- datetime
- string

You can also write 'node' if the property can have any node as value.

The CARDINALITY indicator can be either omitted, in which case the property will
be considered as a single valued property, or be "[]" to indicate the property
has a list of values, or "{}" to indicate the property has a set of values.

For example:

    #### Group ####
    
    User{} members

@sa ::graphene::Prop

The NAME is the property name. It MUST be in camel case starting with a lower
case letter. It can also be the name of an inverse property, as for example:

    #### User ####
    
    Group{} @member

In these cases (as well as in others) it is convenient to add an alias to make the
name more comprehensible, like:

    #### User ####
    
    Group{} @member as groups
    
Those aliases will be reflected both in the query language and in PHP.

The MASK is an entry that gives you control over the access the caller has to the
property. If you omit it, full access is implied (read+update+insert+delete).

But when you start writing your own node classes, you'll soon see that there are
properties you don't wish the caller to update by himself, or even properties you
don't want him to see at all, as it happes with private properties for PHP classes.

The MASK is a character combination of any of the following:

- "r" : for read
- "i" : for insert
- "u" : for update
- "d" : for delete
- "w" : for insert + update + delete
- "f" : full access (the default)
- "n" : no access at all

To make a property read only, for example, you can write:

    #### Bookshop ####
    
    int stockCounter r
    
Or if you want to hide it completely:

    #### Bookshop ####
    
    int stockCounter n

But there are also other combinations that can make sense, for example:

    #### User ####
    
    string password ui

Which tells that the caller can update and insert a password, but can neither
read nor delete it.

The FLAGS are any combination of the following:

- "required"
- "unique"
- "delete cascade"

The \em required flag indicates that the property is required, i.e. no node of 
this type can exist without it. This implies that the property has to be passed
in the initailization aruments at node creation, and that it can not be deleted
(if if the MASK tells it can).

The \em unique flag indicates that every value on this property must be different 
than any other. For example:

    #### User ####
    
    string email unique required

Notice that in Graphene properties are shared among types, and 
\em unique means unique in general, not just for this type. Make sure if you use
the same property on different types to make it unique everywhere or not make it 
unique at all. For the moment Graphene has no detection mechanism for this kind of
inconsistency, and you might end up with errors.

The \em delete \em cascade flag only makes sense on node properties. It indicates 
that when the node is deleted, also the node(s) on the on the other side of
the relation should be deleted.

For example:

    #### Person ####
    
    Address addres delete cascade

Which will cause the \em Address to be deleted along with the \em Person.

At the very end of the line, you can place an exclamation mark ("!"). This one
indicates the property is \em frozen, so Graphene won't touch it anymore.

    #### MyType ####
    
    string{} myProp rw !

You should get accostumed to this, since it is very useful during development.

Notice that freezing all properties and freezing the whole type using the
\em \\frozen directive IS NOT the same thing. Unless you freeze the whole type,
other properties can be added dynamically if Graphene is in \em unfrozen mode.

@sa \ref freeze-unfreeze


These are two examples of quite refined definition files you will find in the 
\em UserManager example in the graphene \em examples directory.

     ##### um_User #####
     
     \frozen
     
     string email required unique !
     
     # The password can be update and set, but can not be read, so no amateur
     # programmer has the chance to print it out to the public by mistake.
     string password ui required !
     
     # The nickname can be used to login as an alternative to the email, and has 
     # the advantage that you can safely print it out on a web page without violating
     # the users privacy.
     string nickname unique !
     
     # Following two are 'private' and I give no direct access to them (the little 'n').
     string token n unique !
     datetime tokenExpires n !
     
     # The subscribed groups.
     Group{} groups !                                    
     
and:

    ##### um_Group #####
    
    \frozen
    
    # I call the property 'groupName' instead of 'name' since it
    # has to be unique and 'name' is a little too general (I might
    # want to use it elsewhere as well). 
    # In order to make lazy programmers happy nevertheless, I define 'name' 
    # as an alias.
    string groupName as name required unique !
    
    # This property is maintained programmatically and I don't want anybody to
    # mess around with it. That's why I define it as read only (the little 'r').
    Group{} ancestors r !
    
    # The inverse of 'ancestors', i.e. 'descendants'.
    # I set it as read only just for clarity: it is already read only 
    # since its inverse is read only...
    Group{} @ancestors as descendants r !
    
    # The set of privileges granted to this group, as strings. This is a quite
    # simplistic solution (maybe privileges should better be nodes so that 
    # we can attached some metadata to them), but it has the advantage to be 
    # quite efficient, which is probably more important in this context.
    # We can still create later on some metadata linking them to our privileges by name.
    string{} privileges !
    
    # Here as well I define a shorter alias for lazy programmers.
    Group parentGroup as parent !
    
    # The (multiple) inverse of 'parentGroup' aka 'parent', i.e. 'children'.
    # I pedantically set it as 'unique' as an additional check to ensure
    # each group has at most one parent, although this should be achieved already
    # by the fact that 'parentGroup' is single valued... 
    Group{} @parentGroup as children unique !
    
    # Give a nice name to the inverse of 'groups'.
    User{} @groups as members !
    


@page def-files The Graphene definition files
@brief Syntax and usage.

*/



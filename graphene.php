<?php

/*   IMPORTANT NOTE FOR CONTRIBUTORS

Hello, and welcome to Graphene.

1. CODING

    There are some oddities in the code you shuld be warned about.
    
    First of all, and for hystorical reasons, the lower level classes are still
    in slug_case (I adopted the camelCase convention only recently). 
    This does not affect the public API but will look strange to contributors.
    As soon as I have the time to do it, I'll restyle thoses classes (well, if 
    someone else hasn't done it before...).
    
    Secondly I'm aware of the fact that I do not follow many of the best 
    practices in code styling. For example I always write:
    
        if( something ) {
    
    instead of:
    
        if (something) {
        
    I apologize for this, but unfortunately I only recently was told there is 
    a thing called php-fig (http://www.php-fig.org/psr/psr-2/) which I'm willed
    to adopt from now on and so should you if you happen to contribute.


2. TESTING

    There are no formal tests yet, sorry for that. 
    
    For the moment the only tests you can run are the examples. They do test a 
    lot of stuff and if you launch them and they work correctly (no 'Ooops' or 
    mean exceptions in the output) this should be interpreted at least as a very 
    good sign nothing is broken.
    
    On how to run the examples go to the examples directory and read the README 
    file.


3. HAVE FUN

    Those things being said, thanks for your interest, have fun and let me know.


- Max Jacob 02 2015
*/



/**

\section def-file-naming Naming

Each definition file specifies the data structure of the corresponding node type. 
The file must have the same name as the type and be placed in the \em definitions 
directory of the classpath. 

If the type is in a namespace, the definition file must be in a subdirectory having
the same name as the namespace. For example a type \em ab_cd_SomeType will have it's
definition file in:

    {classpath}/definitions/ab/cd/SomeType.def
    
While a type in the root namespace, for example \em MyType will be located directly
on the \em definitions directory root:

    {classpath}/definitions/MyType.def

@sa \ref type-names
    
Usually you should start coding with Graphene in unfrozen mode (see \ref freeze-unfreeze)
and the definition files will be created automatically.

But of course you can do it the other way aroud, if you like it better: creating the
definition files first, and then start coding, which is a more traditional approach.

\section def-file-syntax Syntax

\subsection def-file-comments Comments

Comments are lines that start with a '#' character. Such lines will be ignored by
the interpreter and can be used for annotations. The files generated by graphene 
have a headline comment with the type name, and before each generated property
there is a comment like this:

    # AUTO-GENERATED
    
You should remove that comment when you revise the property, so you will remember
it is not the auto-generated version anymore, and place your own comments.

\subsection def-file-directives Directives

Comments by side, the first lines a def file can contain are the (optional) directives.

The general syntax for a directive is:

    \\DIRECTIVE_NAME [DIRECTIVE_PARAMS]

At the time being there are only two directives:

    \\frozen 

Which tells the whole type is frozen, i.e. Graphene will not add any
property nor modify the existing ones.

The second directive you can insert is:

    \\supertype TYPE_NAME

Which indicates that this type extends another type.
The type name will be interpreted as relative to the current type's namespace.

@sa \ref type-names

\subsection property-defs Property definitions

The syntax of a property definition is:

    PROP_DEF := (NODE_TYPE|DATA_TYPE)[CARDINALITY] NAME ["as" ALIAS] [MASK] [FLAGS] ["!"]


NODE_TYPE is the type of node that is expected as value of that property. 
For example:

    Person owner
    
Indicates that the \em owner property should have Person nodes as values.

@sa \ref type-names

For data properties (i.e. not node properties), you write the insead th DATA_TYPE, 
which is one among following:

- int
- float                                       
- datetime
- string

You can also write 'node' if the property can have any node as value.

The CARDINALITY indicator can be either omitted, in which case the property will
be considered as a single valued property, or be "[]" to indicate the property
has a list of values, or "{}" to indicate the property has a set of values.

For example:

    #### Group ####
    
    User{} members

@sa ::graphene::Prop

The NAME is the property name. It MUST be in camel case starting with a lower
case letter. It can also be the name of an inverse property, as for example:

    #### User ####
    
    Group{} @member

In these cases (as well as in others) it is convenient to add an alias to make the
name more comprehensible, like:

    #### User ####
    
    Group{} @member as groups
    
Those aliases will be reflected both in the query language and in PHP.

The MASK is an entry that gives you control over the access the caller has to the
property. If you omit it, full access is implied (read+update+insert+delete).

But when you start writing your own node classes, you'll soon see that there are
properties you don't wish the caller to update by himself, or even properties you
don't want him to see at all, as it happes with private properties for PHP classes.

The MASK is a character combination of any of the following:

- "r" : for read
- "i" : for insert
- "u" : for update
- "d" : for delete
- "w" : for insert + update + delete
- "f" : full access (the default)
- "n" : no access at all

To make a property read only, for example, you can write:

    #### Bookshop ####
    
    int stockCounter r
    
Or if you want to hide it completely:

    #### Bookshop ####
    
    int stockCounter n

But there are also other combinations that can make sense, for example:

    #### User ####
    
    string password ui

Which tells that the caller can update and insert a password, but can neither
read nor delete it.

The FLAGS are any combination of the following:

- "required"
- "unique"
- "delete cascade"

The \em required flag indicates that the property is required, i.e. no node of 
this type can exist without it. This implies that the property has to be passed
in the initailization aruments at node creation, and that it can not be deleted
(if if the MASK tells it can).

The \em unique flag indicates that every value on this property must be different 
than any other. For example:

    #### User ####
    
    string email unique required

Notice that in Graphene properties are shared among types, and 
\em unique means unique in general, not just for this type. Make sure if you use
the same property on different types to make it unique everywhere or not make it 
unique at all. For the moment Graphene has no detection mechanism for this kind of
inconsistency, and you might end up with errors.

The \em delete \em cascade flag only makes sense on node properties. It indicates 
that when the node is deleted, also the node(s) on the on the other side of
the relation should be deleted.

For example:

    #### Person ####
    
    Address addres delete cascade

Which will cause the \em Address to be deleted along with the \em Person.

At the very end of the line, you can place an exclamation mark ("!"). This one
indicates the property is \em frozen, so Graphene won't touch it anymore.

    #### MyType ####
    
    string{} myProp rw !

You should get accostumed to this, since it is very useful during development.

Notice that freezing all properties and freezing the whole type using the
\em \\frozen directive IS NOT the same thing. Unless you freeze the whole type,
other properties can be added dynamically if Graphene is in \em unfrozen mode.

@sa \ref freeze-unfreeze




@page def-files Definition files
@brief The syntax of the def(inition) files

*/

/**


NOTE: The Graphene Query Language is still at it's early stages and does not
yet have all the features we'd like. It will probably be extended in a close 
future, but maintaining backwards compatibility.

\section gql-syntax Syntax

For simple purposes, the GQL is not very different form a SQL 'WHERE' clause 
optionally followed by an 'ORDER BY' and/or by a 'LIMIT' clause.

For example:
    
    $db->select("title='Finnegans wake' AND (copies>10 OR published<'2014-01-01')");

will give you back all nodes having a \em title equal to "Finnegans wake" and 
having either more tha 10 \em copies or being \em published before 2014.

The first subtle difference is that in Graphene properties can be multiple, and
thus "title='Finnegans wake'" does select any node having \em at \em least one
title equal to "Finnegans wake" (and at least one value > 10 on the property 
\em copies and so on).

If for example I want to find all groups a user with id, let's say, 2589 belongs
to, I can query:

    "member=2589"

And it will return all groups where the property members contains the value 2589,
which is what I wanted.

A second subtle difference is that in Graphene the corresponding of the SQL NULL
value is simply that the property does not exist (has no values). So you can 
query:

    "firstName"

And will get back all nodes having at least one value on the property \em firstName.
By querying instead:

    "not firstName"
    
You will get all nodes that don't have any first name.

The third and most important difference though is that in Graphene you can 
build paths:

    "group.name='admin'"

Will return all nodes having a \em group whose name is 'admin'.

When you repeat a piece of path twice, the interpreter will argue you are talking 
about the same node. For example:

    "group.name='admin' and group.created<'2014-01-01'"

Will return all nodes having a \em group whose name is 'admin' and that has been
created before 2014. But sometimes you dont want this. For example:

    "group.name='admin' and group.name='community'"

Will probably return nothing, since it is looking for members of a group whose name
is 'admin' \em and \em also 'community'. It these cases you are referring to two different
groups and you can tell the interpreter by giving those groups a name:

    "group#g1.name='admin' and group#g2.name='community'"

Now it will return any node being a member of both groups, one bound to \em \#g1 and the
other one bound to \em \#g2.

You can reuse the name later on in the query, without having to rewrite the piece
of path it stands for, for example:

    "group#g1.name='admin' and #g1.created<'2014-01-01'"

When you make a query, the node you are looking for is always bound to the name \em \#x.
If you query:

    "group=#x"

It will give you back all nodes having themselves as \em group.
Sometimes you want to write the \em \#x out always, for clarity:

    "#x.group=#x"

or:

    "#x.title='Finnegans wake'"

which doens't affect the query in any way.
    
The fourth (and last) peculiarity of GQL is that you have a notation saying a
given node must be of a given type:

    "User#x and Group#g and #x.group=#g and #g.name='admin'"

Will give back all nodes of type \em User having a node of type \em Group as group.
This is quite verbose, and you could reduce the query to:

    "User#x and group.name='admin'
    
As long as in your database the property \em groups in respect to User nodes 
always yelds Group nodes anyway.






@page gql The Graphene Query Language

*/


require_once 'src/Connection.php';

/**
@brief The connection factory.
*/

class graphene 
{
    
    private static $connections=array();
    private static $autoloading=false;
    
    /**
    @brief Opens a database connection.
    
    @param $params An associative array containing the connection params.
    
    @return a graphene::Connection object.
    
    For example:
    
        $db=graphene::open(array(
            "host"=>"localhost",
            "user"=>"dummy",
            "pwd"=>"dummy",
            "db"=>"test",
            "port"=>null,
            "prefix"=>"",
            "classpath"=>"./model"
        ));
     
     The host, user, pwd and db name must e those of a MySql database you have 
     access to.
     
     The port can be omitted or set to null, in which case the default MySql 
     port (3306) will be used. 
     
     The prefix also is optional and only useful if 
     you want several Graphene databases in a single MySql database: if you the
     prefix will be added to the name of all grahene tables, so there can be
     several sets of such tables you connect to with the same database params
     but with a different prefix.
     
     The classpath is where Graphene should store its definition files and where 
     it should search your custom classes, if any.
        
    */
    public static function open($params) 
    {
        $id='k'.count(self::$connections);
        $conn=\graphene\Connection::_open($params,$id);
        self::$connections[$id]=$conn;
        return $conn;
    }
    
    public static function loadClass($name) 
    {
        foreach (self::$connections as $id=>$conn) {
            if ($conn->_loadClass($name)) break;
        }
    }
    
    public static function enableAutoload() 
    {
        if (!self::$autoloading) {
            spl_autoload_register(array('\Graphene','loadClass'));
            self::$autoloading=true;
        }
    }
    
    public static function _close($id) 
    {
        unset(self::$connections[$id]);
    }
    
    const ACCESS_NONE=0;
    const ACCESS_READ=1;
    const ACCESS_INSERT=2;
    const ACCESS_DELETE=4;
    const ACCESS_UPDATE=8;
    const ACCESS_WRITE=14;
    const ACCESS_FULL=15;
    
    
}


